group java;

/**
 * * Estrutura geral de um programa C++:
 * @decl_funcs: declarações das funções p/ caso venham em ordens diferentes.
 * @funcs: cabeçalho e corpo das funções.
 * @data_decls: definição dos dados e dados abstratos.
 */
program(decl_funcs, funcs, deta_decls) ::= <<
#include \<iostream>
#include \<tuple>

using namespace std;

<deta_decls; separator="\n\n">

<decl_funcs>

int main(int argc, char* argv[]) {
    cout \<\< boolalpha;
    _main_aux();
}

<funcs; separator="\n\n">
>>

/**
 * * Declaração de funções no cabeçalho do programa
 * @types: lista de tipos do retorno.
 * @name: nome da função
 * @params: parâmetros da função.
 */
decl_func(types, name, params) ::= <<
<if(types)>
tuple\< <types; separator=", "> > _<name>(<params; separator=", ">);
<else>
void _<name>(<params; separator=", ">);
<endif>    
>>

/**
 * * Estrutura geral de uma função 
 * @types: lista de tipos do retorno.
 * @name: nomes da função.
 * @vardecls: declarações de variável.
 * @params: parâmetros da função.
 * @blockCmds: blocos de comandos.
 * @flagStatic: flag para adicionar static no cabeçalho. Útil para quando a função pertence a uma classe.
 */
func(types, flagStatic, name, params, vardecls, blockCmds) ::= <<
<if(types)>
<if(flagStatic)>static <endif>tuple\< <types; separator=", "> > _<name>(<params; separator=", ">) {
<else>
<if(flagStatic)>static <endif>void _<name>(<params; separator=", ">) {
<endif>
    <if(vardecls)><vardecls; separator=";\n">;<endif>
    <if(blockCmds)><blockCmds; separator="\n"><endif>
}
>>

/**
 * * Declaração de variáveis no início das funções.
 * @type: tipo da variável
 * @name: nome da variável
 */
var_decl(type, name) ::= <<
<type> <name>
>>

/**
 * * Atribuição de valor a variável
 * @var: nome da variável
 * @expr: valor que será escrito
 */
attr(var, expr) ::= <<
<var> = <expr>;
>>

/**
 * * Estrutura de um parâmetro de uma função. similar ao var_decl.
 */
param(type, name) ::= "<type> <name>"

// * Nome dos tipos no formato do do C++
int_type() ::= "int"
float_type() ::= "float"
bool_type() ::= "bool"
char_type() ::= "char"

// * Concatena dois stms. 
stmt_type(stmt1, stmt2) ::= <<
<stmt1><stmt2>
>>

/*Impressão de valor usando cout*/
print(expr) ::= "cout \<\< <expr>;"

/*Leitura de valor usando cin*/
read(expr) ::= "cin >> <expr>;"

//===========================================================================================
/*Comandos de OPERAÇÕES*/
mul_expr(left_expr, right_expr) ::= "(<left_expr> * <right_expr>)"
div_expr(left_expr, right_expr) ::= "(<left_expr> / <right_expr>)"
mod_expr(left_expr, right_expr) ::= "(<left_expr> % <right_expr>)"
add_expr(left_expr, right_expr) ::= "(<left_expr> + <right_expr>)"
sub_expr(left_expr, right_expr) ::= "(<left_expr> - <right_expr>)"
lt_expr(left_expr, right_expr) ::= "(<left_expr> \< <right_expr>)"
equals_expr(left_expr, right_expr) ::= "(<left_expr> == <right_expr>)"
diff_expr(left_expr, right_expr) ::= "(<left_expr> != <right_expr>)"
and_expr(left_expr, right_expr) ::= "(<left_expr> && <right_expr>)"
not_expr(expr) ::= "!<expr>"
minus_expr(expr) ::= "-<expr>"
//===========================================================================================

/*Valores*/
boolean_expr(value) ::= "<value>"
float_expr(value) ::= "<value>"
int_expr(value) ::= "<value>"
null_expr(value) ::= "<value>"
char_expr(value) ::= "<value>"
char_expr_num(value) ::= "static_cast\<char>(<value>)" // ! CASO ESPECIAL PARA CHAR'S ASCII

/*Conversão p/ if e else*/
if(expr, thn, els) ::= <<
if(<expr>) {
    <thn; separator="\n">
} <if(els)>else {
    <els; separator="\n">
}
<endif>
>>

/**
 * * Loop com expr e com var: iterate(expr) ou iterate (i : x)
 * @type: necessário especificar quando for iterate(expr), pois crio uma variável nova auxiliar.
 * @id: armazena resultado do cálculo. Útil quando a condição do iterate sofre modificações. (Caso do sort.lan)
 * @expr: num de iterações
 * @var_name: nome da variavel. se for expr eu crio um, senão pega o que vem de lá. no exemplo acima seria "i"
 * @cmds: comandos do loop.
 */
while(type, id, expr, var_name, cmds) ::= <<
int __aux___expr__save__<id> = <expr>;
for(<if(type)>int<endif> <var_name> = 0 ; <var_name> \< __aux___expr__save__<id>; <var_name>++) {
    <cmds; separator="\n">
}
>>

/**
 * * Loop com vetores. iterate(i : v), onde v é array.
 * @type: necessário para colocar int.
 * @aux_loop: variavel auxiliar que percorre o loop
 * @length: tamanho do array
 * @loop_name: como será chamado baseado no identificador.
 * @array_name: nome do array em Lang
 * @cmds: resto dos comandos
 */
while_array(type, aux_loop, loop_name, array_name, length, cmds) ::= <<
for(<if(type)>int<endif> <aux_loop> = 0; <aux_loop> \< <length>; <aux_loop>++){
    <loop_name> = <array_name>[<aux_loop>];
    <cmds; separator="\n">
}
>>

/*Retorno de variaveis*/
return(list_exprs) ::= <<
return make_tuple(<list_exprs; separator=", ">);
>>

/*Chamada de funções passando as variaveis*/
func_call(flag, namespaceClass, name, params, vars) ::= <<
<if(flag)>auto __return_function_func_call_  = <endif><if(namespaceClass)><namespaceClass>::<endif>_<name>(<params; separator=",">);
<if(flag)><vars; separator="\n"><endif>
>>

/*Chamada pegando indice*/
func_call_access(name, namespaceClass, params, index) ::= <<
get\< <index> >(<if(namespaceClass)><namespaceClass>::<endif>_<name>(<params; separator=", ">))
>>

/* Auxiliar para quando for chamar passando variaveis. Precisa usar esse get<>() */
var_unpacking(var, id) ::= <<
<var> = get\< <id> >(__return_function_func_call_);
>>
/*--------------------------*/

/*Declaração de array*/
new_array(type, index) ::= "new <type>[<index>]"
new_var(type) ::= "new <type>"

/*Acesso a array*/
array_access(expr) ::= "[<expr>]"

/*Usando variavel simples*/
id(name) ::= "<name>"

/*ponteiro*/
pointer() ::= "*"

/*Acesso a atributo*/
attr_access(exp) ::= "-><exp>"

// * concatena dois stmts
stmt_lvalue(stmt1, stmt2) ::= <<
<stmt1><stmt2>
>>

// ---------*----------*--------------*-------------
/* *
 * Struct para quando for data
 */
struct_def(name, var_decls) ::= <<
struct <name>{
    <var_decls; separator=";\n">;
};
>>

/* *
 * Classe para quando for abstract data
 */
class_def(name, var_decls, abstract_funs) ::= <<
class <name> {
    private:
        <var_decls; separator=";\n">;

    public:
        <abstract_funs>
};
>>