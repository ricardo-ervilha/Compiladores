group java;

/*Definição da estrutura geral do programa C++
Programa tem:
 cabeçalho
 uso do namespace std
 chama main auxiliar
 e tem outras funções
*/
program(decl_funcs, funcs, deta_decls) ::= <<
#include \<iostream>
#include \<tuple>

using namespace std;

<deta_decls; separator="\n\n">

<decl_funcs>

int main(int argc, char* argv[]) {
    cout \<\< boolalpha;
    main_aux();
}

<funcs; separator="\n\n">
>>

/*Declaração de funções no cabeçalho do programa*/
decl_func(types, name, params) ::= <<
<if(types)>
tuple\< <types; separator=", "> > <name>(<params; separator=", ">);
<else>
void <name>(<params; separator=", ">);
<endif>    
>>

/*Estrutura geral das funções do programa
func tem retorno, parametros, nome e 
- declaração de variaveis
- comandos
*/
func(types, name, params, vardecls, blockCmds) ::= <<
<if(types)>
tuple\< <types; separator=", "> > <name>(<params; separator=", ">) {
<else>
void <name>(<params; separator=", ">) {
<endif>
    <if(vardecls)><vardecls; separator=";\n">;<endif>
    <if(blockCmds)><blockCmds; separator="\n"><endif>
}
>>

/*Declaração das variáveis no início das funções.*/
var_decl(type, name) ::= <<
<type> <name>
>>

/*Atribuição de valor a variável.*/
attr(var, expr) ::= <<
<var> = <expr>;
>>

/*Parâmetro das funções*/
param(type, name) ::= "<type> <name>"

/*Nome dos tipos no formato do do C++*/
int_type() ::= "int"
float_type() ::= "float"
bool_type() ::= "bool"
char_type() ::= "char"

stmt_type(stmt1, stmt2) ::= <<
<stmt1><stmt2>
>>

/*Impressão de valor*/
print(expr) ::= "cout \<\< <expr>;"

/*Leitura*/
read(expr) ::= "cin >> <expr>;"


/*Comandos de OPERAÇÕES*/
mul_expr(left_expr, right_expr) ::= "(<left_expr> * <right_expr>)"
div_expr(left_expr, right_expr) ::= "(<left_expr> / <right_expr>)"
mod_expr(left_expr, right_expr) ::= "(<left_expr> % <right_expr>)"
add_expr(left_expr, right_expr) ::= "(<left_expr> + <right_expr>)"
sub_expr(left_expr, right_expr) ::= "(<left_expr> - <right_expr>)"
lt_expr(left_expr, right_expr) ::= "(<left_expr> \< <right_expr>)"
equals_expr(left_expr, right_expr) ::= "(<left_expr> == <right_expr>)"
diff_expr(left_expr, right_expr) ::= "(<left_expr> != <right_expr>)"
and_expr(left_expr, right_expr) ::= "(<left_expr> && <right_expr>)"
not_expr(expr) ::= "!<expr>"
minus_expr(expr) ::= "-<expr>"

/*Valores*/
boolean_expr(value) ::= "<value>"
float_expr(value) ::= "<value>"
int_expr(value) ::= "<value>"
null_expr(value) ::= "<value>"
char_expr(value) ::= "<value>"
char_expr_num(value) ::= "static_cast\<char>(<value>)"

/*CMD if e else*/
if(expr, thn, els) ::= <<
if(<expr>) {
    <thn; separator="\n">
} <if(els)>else {
    <els; separator="\n">
}
<endif>
>>

/*Loop*/
while(type, expr, var_name, cmds) ::= <<
for(<if(type)>int<endif> <var_name> = <expr>; <var_name> > 0; <var_name>--) {
    <cmds; separator="\n">
}
>>

/*Retorno de variaveis*/
return(list_exprs) ::= <<
return make_tuple(<list_exprs; separator=", ">);
>>

/*Chamada de funções passando as variaveis*/
func_call(name, params, vars) ::= <<
auto __return_function_func_call_ = <name>(<params; separator=",">);
<vars; separator="\n">
>>

var_unpacking(var, id) ::= <<
<var> = get\< <id> >(__return_function_func_call_);
>>
/*--------------------------*/

/*Declaração de array*/
new_array(type, index) ::= "new <type>[<index>]"
new_var(type) ::= "new <type>"

/*Acesso a array*/
array_access(expr) ::= "[<expr>]"

/*Usando variavel simples*/
id(name) ::= "<name>"

/*ponteiro*/
pointer() ::= "*"

/*Acesso a atributo*/
attr_access(exp) ::= "-><exp>"

stmt_lvalue(stmt1, stmt2) ::= <<
<stmt1><stmt2>
>>

// ---------*----------*--------------*-------------
struct_def(name, var_decls) ::= <<
typedef struct{
    <var_decls; separator=";\n">;
} <name>;
>>

var_decl_class(type, name) ::= <<
private <type> <name>
>>

class_def(name, var_decls, abstract_funs) ::= <<
class <name> {
    <var_decls; separator=";\n">;

    <abstract_funs>
};
>>