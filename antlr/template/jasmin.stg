group jasmin;

program(name, funcs) ::= <<
.source <name>
.class public <name>
.super java/lang/Object

    <funcs; separator="\n\n">

    .method public static main([Ljava/lang/String;)V
        .limit stack 1
        invokestatic <name>/main_aux()V
        return
    .end method
>>


// Template para funções
func(return, name, params, decls, stack, stmt) ::= <<
.method static <name>(<params>)<return>
    .limit stack <stack>
    .limit locals <decls>
    <stmt>
.end method
>>

// Template para um bloco: uma sequência de comandos
block(cmds) ::= <<
    <cmds; separator="\n">
>>

empty() ::= <<>>
iprint(expr) ::= <<
getstatic java/lang/System/out Ljava/io/PrintStream;
<expr>
invokevirtual java/io/PrintStream/println(I)V
>>

fprint(expr) ::= <<
getstatic java/lang/System/out Ljava/io/PrintStream;
<expr>
invokevirtual java/io/PrintStream/println(F)V
>>

cprint(expr) ::= <<
getstatic java/lang/System/out Ljava/io/PrintStream;
<expr>
invokevirtual java/io/PrintStream/println(C)V
>>

bprint(expr) ::= <<
getstatic java/lang/System/out Ljava/io/PrintStream;
<expr>
invokevirtual java/io/PrintStream/println(Z)V
>>

ireturn(expr) ::= <<
<expr>
ireturn
>>

freturn(expr) ::= <<
<expr>
freturn
>>

vreturn() ::= <<

return
>>

while(num,expr, stmt) ::= <<
#<num>:
<expr>
ifeq #<num>#end
<stmt>
goto #<num>
#<num>#end:
nop
>>

// Template para if-else
if_else(elseNum, endNum, expr, thenBlock, elseBlock) ::= <<
<expr>
ifeq L<elseNum>
    <thenBlock>
    goto L<endNum>
L<elseNum>:
    <elseBlock>
L<endNum>:
nop
>>



iarray(num, expr) ::= <<
<expr>
newarray int
astore <num>
>>

call(class, name, type, return, args) ::= <<
<args; separator="\n">
invokestatic <class>/<name>(<type>)<return>
>>

istore(num, expr) ::= <<
<expr>
istore <num>
>>

iastore(num, index, expr) ::= <<
aload <num>
<index>
<expr>
iastore
>>

iaccess(num) ::= "iload <num>"

iaaccess(num, expr) ::= <<
aload <num>
<expr>
iaload
>>

iaload(num) ::= <<
aload <num>
>>


// Operadores Binários e Unários: Aritméticos e Relacionais
imul(left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
imul
>>

idiv(left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
idiv
>>

imod(left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
irem
>>

iadd(left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
iadd
>>

isub(left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
isub
>>

ilt_expr(num, left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
isub
iflt #<num>
iconst_0
goto #<num>#<num>
#<num>:
iconst_1
#<num>#<num>:
>>

flt_expr(num, left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
fcmpl
iflt #<num>
iconst_0
goto #<num>#<num>
#<num>:
iconst_1
#<num>#<num>:
>>

iequals_expr(num, left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
isub
ifeq #<num>
iconst_0
goto #<num>#<num>
#<num>:
iconst_1
#<num>#<num>:
>>

fequals_expr(num, left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
fcmpl
ifeq #<num>
iconst_0
goto #<num>#<num>
#<num>:
iconst_1
#<num>#<num>:
>>

not_expr(expr) ::= <<
<expr>
iconst_1
ixor
>>

and_expr(left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
iand
>>

ineg_expr(expr) ::= <<
<expr>
ineg
>>

fneg_expr(expr) ::= <<
<expr>
fneg
>>


// Mapeamento de tipos
array_type(type) ::= "[<type>"
int_type() ::= "I"
float_type() ::= "F"
boolean_type() ::= "Z"
char_type() ::= "C"

// Expressões de valores
boolean_true() ::= "iconst_1"
boolean_false() ::= "iconst_0"
float_expr(value) ::= "ldc <value>"
int_expr(value) ::= "sipush <value>"
char_expr(value) ::= "ldc <value>"
