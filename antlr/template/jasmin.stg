group jasmin;

program(name, funcs) ::= <<
.source <name>
.class public <name>
.super java/lang/Object

    <funcs; separator="\n\n">

    .method public static main([Ljava/lang/String;)V
        .limit stack 1
        invokestatic <name>/main_aux()V
        return
    .end method
>>


// Template para funções
func(return, name, params, decls, stack, stmt) ::= <<
.method static <name>(<params>)<return>
    .limit stack <stack>
    .limit locals <decls>
    <stmt>
.end method
>>

// Template para um bloco: uma sequência de comandos
block(cmds) ::= <<
    <cmds; separator="\n">
>>

empty() ::= <<>>
iprint(expr) ::= <<
getstatic java/lang/System/out Ljava/io/PrintStream;
<expr>
invokevirtual java/io/PrintStream/println(I)V
>>

fprint(expr) ::= <<
getstatic java/lang/System/out Ljava/io/PrintStream;
<expr>
invokevirtual java/io/PrintStream/println(F)V
>>

cprint(expr) ::= <<
getstatic java/lang/System/out Ljava/io/PrintStream;
<expr>
invokevirtual java/io/PrintStream/println(C)V
>>

bprint(expr) ::= <<
getstatic java/lang/System/out Ljava/io/PrintStream;
<expr>
invokevirtual java/io/PrintStream/println(Z)V
>>

ireturn(expr) ::= <<
<expr>
ireturn
>>

freturn(expr) ::= <<
<expr>
freturn
>>

vreturn() ::= <<

return
>>

while(num,expr, stmt) ::= <<
Label<num>:
<expr>
ifeq Label<num>end
<stmt>
goto Label<num>
Label<num>end:
nop
>>

// Template para if-else
if_else(elseNum, endNum, expr, thenBlock, elseBlock) ::= <<
<expr>
ifeq Label<elseNum>
<thenBlock>
    goto Label<endNum>
Label<elseNum>:
<elseBlock>
Label<endNum>:
>>

// ==================== LOAD VARIAVEL SIMPES (SLOT --> PILHA) ====================

load_int(indexSlot) ::= <<
iload <indexSlot> ; carrega a varivael do slot indexSlot para a pilha
>>

load_array(indexSlot) ::= <<
aload <indexSlot> ; carrega array do slot indexSlot para a pilha
>>

iaccess(num) ::= "iload <num>"

iaaccess(indexSlot, indexArray, typeAload) ::= <<
<indexSlot> ; carrega array do slot indexSlot para a pilha, depois vem expressão
<indexArray>            ; index do array
<typeAload> ; iaload, falod, etc
>>


// ==================== STORE VARIAVEL SIMPES (PILHA --> SLOT) ====================

store_int(indexSlot, rhs) ::= <<
<rhs>
istore <indexSlot>
>>

store_float(indexSlot, rhs) ::= <<
<rhs>
fstore <indexSlot>
>>

// ==================== STORE ARRAY ====================

store_array(indexSlot, rhs) ::= <<
<rhs>
astore <indexSlot>    ; salva o array no slot indexSlot
>>

iarray(num, expr) ::= <<
<expr>          ; expressão que calcula o tamanho do array
newarray int    ; cria o array int pegando da pilha o tamanho
>>

carray(num, expr) ::= <<
<expr>
newarray char   ; cria array de chars
>>

barray(num, expr) ::= <<
<expr>
newarray boolean ;cria array de booleans
>>

farray(num, expr) ::= <<
<expr>
newarray float  ;cria array de floats
>>

// ==================== STORE ELEMENTO DE ARRAY ====================

astore_int_array(arrayRef, indexExpr, rhs) ::= <<
<arrayRef>
<indexExpr>
<rhs>
iastore
>>

astore_float_array(arrayRef, indexExpr, rhs) ::= <<
<arrayRef>
<indexExpr>
<rhs>
fastore
>>

// ==================== STORE REGISTRO ====================
putfield_int(objRef, fieldName, fieldDescriptor, rhs) ::= <<
<objRef>
<rhs>
putfield <fieldName> <fieldDescriptor>
>>

putfield_float(objRef, fieldName, fieldDescriptor, rhs) ::= <<
<objRef>
<rhs>
putfield <fieldName> <fieldDescriptor>
>>




call(class, name, type, return, args) ::= <<
<args; separator="\n">
invokestatic <class>/<name>(<type>)<return>
>>

istore(num, expr) ::= <<
<expr>
istore <num>
>>

iastore(num, index, expr) ::= <<
aload <num>
<index>
<expr>
iastore
>>






// Operadores Binários e Unários: Aritméticos e Relacionais
imul(left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
imul
>>

idiv(left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
idiv
>>

imod(left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
irem
>>

iadd(left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
iadd
>>

isub(left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
isub
>>

ilt_expr(num, left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
isub
iflt Label<num>
    iconst_0
    goto Label<num>end
Label<num>:
    iconst_1
Label<num>end:
>>

flt_expr(num, left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
fcmpl
iflt Label<num>
    iconst_0
    goto Label<num>end
Label<num>:
    iconst_1
Label<num>end:
>>

iequals_expr(num, left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
isub
ifeq Label<num>
    iconst_0
    goto Label<num>end
Label<num>:
    iconst_1
Label<num>end:
>>

fequals_expr(num, left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
fcmpl
ifeq Label<num>
    iconst_0
    goto Label<num>end
Label<num>:
    iconst_1
Label<num>end:
>>

not_expr(expr) ::= <<
<expr>
iconst_1
ixor
>>

and_expr(left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
iand
>>

ineg_expr(expr) ::= <<
<expr>
ineg
>>

fneg_expr(expr) ::= <<
<expr>
fneg
>>


// Mapeamento de tipos
array_type(type) ::= "[<type>"
int_type() ::= "I"
float_type() ::= "F"
boolean_type() ::= "Z"
char_type() ::= "C"

// Expressões de valores
boolean_true() ::= "iconst_1"
boolean_false() ::= "iconst_0"
float_expr(value) ::= "ldc <value>"
int_expr(value) ::= "sipush <value>"
char_expr(value) ::= "ldc <value>"
