group jasmin;

program(name, funcs) ::= <<
.source <name>
.class public <name>
.super java/lang/Object

    <funcs; separator="\n\n">

    .method public static main([Ljava/lang/String;)V
        .limit stack 1
        invokestatic <name>/main_aux()V
        return
    .end method
>>

// ==================== SEQUENCIA DE COMANDOS ====================
block(cmds) ::= <<
    <cmds; separator="\n">
>>

// ==================== DECLARAÇÃO DAS FUNÇÕES ====================
func(return_descriptor, name, params, decls, stack, stmt) ::= <<
.method static <name>(<params>)<return_descriptor>
    .limit stack <stack>
    .limit locals <decls>
    <stmt>
.end method
>>

// ==================== TIPOS DE RETORNO ====================
expr_multi_return(slot_arr_ret, idx_arr_ret, expr_ret, expr_save_arr) ::= <<

;expressões de retorno
aload <slot_arr_ret>    ; carregar o array que vai ser usado para retornar os valores
sipush <idx_arr_ret>    ; idx do array onde vai ser salvo
<expr_ret>              ; expr para colocar o valor que tem que ser salvo na pilha
<expr_save_arr> ; finalmente salvar o valor
>>

multi_return(slot_arr_ret, inst_create_array, exprs_multi_ret) ::= <<
; Criar array para os retornos
<inst_create_array>
astore <slot_arr_ret>

;expressões de retorno
<exprs_multi_ret>

; Retornar o array
aload <slot_arr_ret>
areturn
>>

ireturn(expr) ::= <<
<expr>
ireturn
>>

freturn(expr) ::= <<
<expr>
freturn
>>

// template para add return quando o corpo não tem comando return
vreturn() ::= <<

return
>>

// ==================== EXPRESSÃO DE CHAMADA DE FUNÇÃO ====================
// invokestatic Programa/f1()I
call_func_expr(class, func_name, type, return_descriptor, args, expr_idx_ret, typeAload) ::= <<
<args; separator="\n">
invokestatic <class>/<func_name>(<type>)<return_descriptor>
<expr_idx_ret> ;indice do array de retorno que sera acesado
<typeAload>
>>

// ==================== COMANDO DE CHAMADA DE FUNÇÃO ====================
// talvez não precise desse templa, pdendo usar de cima
// comando e expressão são a mesma coisa !?

// ==================== PRINTS ====================
iprint(expr) ::= <<
getstatic java/lang/System/out Ljava/io/PrintStream;
<expr>
invokevirtual java/io/PrintStream/println(I)V
>>

fprint(expr) ::= <<
getstatic java/lang/System/out Ljava/io/PrintStream;
<expr>
invokevirtual java/io/PrintStream/println(F)V
>>

cprint(expr) ::= <<
getstatic java/lang/System/out Ljava/io/PrintStream;
<expr>
invokevirtual java/io/PrintStream/println(C)V
>>

bprint(expr) ::= <<
getstatic java/lang/System/out Ljava/io/PrintStream;
<expr>
invokevirtual java/io/PrintStream/println(Z)V
>>

// ==================== COMANDO READ ====================

iread(indexSlot) ::= <<
new java/util/Scanner
dup
getstatic java/lang/System/in Ljava/io/InputStream;
invokespecial java/util/Scanner/\<init>(Ljava/io/InputStream;)V
invokevirtual java/util/Scanner/nextInt()I
istore <indexSlot>
>>

fread(indexSlot) ::= <<
; --- Leitura de um Float ---
new java/util/Scanner
dup
getstatic java/lang/System/in Ljava/io/InputStream;

invokespecial java/util/Scanner/\<init>(Ljava/io/InputStream;)V
invokevirtual java/util/Scanner/nextFloat()F
fstore <indexSlot>
>>

bread(indexSlot) ::= <<
; --- Leitura de um Booleano ---
new java/util/Scanner
dup
getstatic java/lang/System/in Ljava/io/InputStream;
invokespecial java/util/Scanner/\<init>(Ljava/io/InputStream;)V
invokevirtual java/util/Scanner/nextBoolean()Z
istore <indexSlot>
>>

// Lê um caractere da entrada padrão e o armazena no slot <indexSlot>
cread(indexSlot) ::= <<
; --- Leitura de um Caractere ---
new java/util/Scanner
dup
getstatic java/lang/System/in Ljava/io/InputStream;
invokespecial java/util/Scanner/\<init>(Ljava/io/InputStream;)V
invokevirtual java/util/Scanner/next()Ljava/lang/String;
iconst_0
invokevirtual java/lang/String/charAt(I)C
istore <indexSlot>
>>

// ==================== COMANDO READ PARA ARRAYS ====================

// Lê um valor inteiro e armazena em um elemento de array
iread_array(arrayRef, indexExpr) ::= <<
; --- Leitura de Inteiro para Array ---
<arrayRef>              ; carrega referência do array
<indexExpr>             ; carrega índice do array
new java/util/Scanner
dup
getstatic java/lang/System/in Ljava/io/InputStream;
invokespecial java/util/Scanner/\<init>(Ljava/io/InputStream;)V
invokevirtual java/util/Scanner/nextInt()I
iastore                 ; armazena no array[index]
>>

// Lê um valor float e armazena em um elemento de array
fread_array(arrayRef, indexExpr) ::= <<
; --- Leitura de Float para Array ---
<arrayRef>
<indexExpr>
new java/util/Scanner
dup
getstatic java/lang/System/in Ljava/io/InputStream;
invokespecial java/util/Scanner/\<init>(Ljava/io/InputStream;)V
invokevirtual java/util/Scanner/nextFloat()F
fastore
>>

// Lê um valor booleano e armazena em um elemento de array
bread_array(arrayRef, indexExpr) ::= <<
; --- Leitura de Booleano para Array ---
<arrayRef>
<indexExpr>
new java/util/Scanner
dup
getstatic java/lang/System/in Ljava/io/InputStream;
invokespecial java/util/Scanner/\<init>(Ljava/io/InputStream;)V
invokevirtual java/util/Scanner/nextBoolean()Z
bastore
>>

// Lê um caractere e armazena em um elemento de array
cread_array(arrayRef, indexExpr) ::= <<
; --- Leitura de Caractere para Array ---
<arrayRef>
<indexExpr>
new java/util/Scanner
dup
getstatic java/lang/System/in Ljava/io/InputStream;
invokespecial java/util/Scanner/\<init>(Ljava/io/InputStream;)V
invokevirtual java/util/Scanner/next()Ljava/lang/String;
iconst_0
invokevirtual java/lang/String/charAt(I)C
castore
>>




// ==================== ITERATE ====================

// Iterate com inteiro: executa o corpo n vezes
iterate_int(startNum, endNum, countExpr, bodyStmt, totalSlot, currentSlot) ::= <<
<countExpr>           ; coloca o valor n na pilha
istore <totalSlot>    ; salva n no slot totalSlot (contador total)
iconst_0              ; coloca 0 na pilha
istore <currentSlot>  ; salva 0 no slot currentSlot (contador atual)

Label<startNum>:      ; início do loop
iload <currentSlot>   ; carrega contador atual
iload <totalSlot>     ; carrega contador total
if_icmpge Label<endNum>  ; se atual >= total, sai do loop

<bodyStmt>            ; executa o corpo do iterate

iload <currentSlot>   ; carrega contador atual
iconst_1              ; coloca 1 na pilha
iadd                  ; incrementa contador
istore <currentSlot>  ; salva contador incrementado
goto Label<startNum>  ; volta para o início do loop

Label<endNum>:        ; fim do loop
nop
>>

// Iterate com array: executa o corpo array.length vezes
iterate_array(startNum, endNum, arrayExpr, bodyStmt, totalSlot, currentSlot) ::= <<
<arrayExpr>           ; coloca o array na pilha
arraylength           ; pega o tamanho do array
istore <totalSlot>    ; salva tamanho no slot totalSlot (contador total)
iconst_0              ; coloca 0 na pilha
istore <currentSlot>  ; salva 0 no slot currentSlot (contador atual)

Label<startNum>:      ; início do loop
iload <currentSlot>   ; carrega contador atual
iload <totalSlot>     ; carrega contador total
if_icmpge Label<endNum>  ; se atual >= total, sai do loop

<bodyStmt>            ; executa o corpo do iterate

iload <currentSlot>   ; carrega contador atual
iconst_1              ; coloca 1 na pilha
iadd                  ; incrementa contador
istore <currentSlot>  ; salva contador incrementado
goto Label<startNum>  ; volta para o início do loop

Label<endNum>:        ; fim do loop
nop
>>

// ==================== IF-ELSE ====================
if_else(elseNum, endNum, expr, thenBlock, elseBlock) ::= <<
<expr>
ifeq Label<elseNum>
<thenBlock>
    goto Label<endNum>
Label<elseNum>:
<elseBlock>
Label<endNum>:
nop
>>

// ==================== LOAD VARIAVEL SIMPES (SLOT --> PILHA) ====================

load_int(indexSlot) ::= <<
iload <indexSlot> ; carrega a varivael do slot indexSlot para a pilha
>>

load_float(indexSlot) ::= <<
fload <indexSlot> ; carrega a varivael do slot indexSlot para a pilha
>>

load_array(indexSlot) ::= <<
aload <indexSlot> ; carrega array do slot indexSlot para a pilha
>>

iaaccess(indexSlot, indexArray, typeAload) ::= <<
<indexSlot> ; carrega array do slot indexSlot para a pilha, depois vem expressão
<indexArray>            ; index do array
<typeAload> ; iaload, falod, etc
>>

// ==================== STORE VARIAVEL SIMPES (PILHA --> SLOT) ====================

store_int(indexSlot, rhs) ::= <<
<rhs>
istore <indexSlot>
>>

store_float(indexSlot, rhs) ::= <<
<rhs>
fstore <indexSlot>
>>

// ==================== STORE ARRAY ====================

store_array(indexSlot, rhs) ::= <<
<rhs>
astore <indexSlot>    ; salva o array no slot indexSlot
>>

iarray( array_size) ::= <<
<array_size>          ; expressão que calcula o tamanho do array
newarray int    ; cria o array int pegando da pilha o tamanho
>>

carray( array_size) ::= <<
<array_size>
newarray char   ; cria array de chars
>>

barray( array_size) ::= <<
<array_size>
newarray boolean ;cria array de booleans
>>

farray( array_size) ::= <<
<array_size>
newarray float  ;cria array de floats
>>

// ==================== STORE ELEMENTO DE ARRAY ====================

astore_int_array(arrayRef, indexExpr, rhs) ::= <<
<arrayRef>
<indexExpr>
<rhs>
iastore
>>

astore_float_array(arrayRef, indexExpr, rhs) ::= <<
<arrayRef>
<indexExpr>
<rhs>
fastore
>>

// ==================== STORE REGISTRO ====================
putfield_int(objRef, fieldName, fieldDescriptor, rhs) ::= <<
<objRef>
<rhs>
putfield <fieldName> <fieldDescriptor>
>>

putfield_float(objRef, fieldName, fieldDescriptor, rhs) ::= <<
<objRef>
<rhs>
putfield <fieldName> <fieldDescriptor>
>>

call(class, name, type, return, args) ::= <<
<args; separator="\n">
invokestatic <class>/<name>(<type>)<return>
>>

istore(num, expr) ::= <<
<expr>
istore <num>
>>

iastore(num, index, expr) ::= <<
aload <num>
<index>
<expr>
iastore
>>






// Operadores Binários e Unários: Aritméticos e Relacionais
imul(left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
imul
>>

idiv(left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
idiv
>>

imod(left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
irem
>>

iadd(left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
iadd
>>

isub(left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
isub
>>

ilt_expr(num, left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
isub
iflt Label<num>
    iconst_0
    goto Label<num>end
Label<num>:
    iconst_1
Label<num>end:
>>

flt_expr(num, left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
fcmpl
iflt Label<num>
    iconst_0
    goto Label<num>end
Label<num>:
    iconst_1
Label<num>end:
>>

iequals_expr(num, left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
isub
ifeq Label<num>
    iconst_0
    goto Label<num>end
Label<num>:
    iconst_1
Label<num>end:
>>

fequals_expr(num, left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
fcmpl
ifeq Label<num>
    iconst_0
    goto Label<num>end
Label<num>:
    iconst_1
Label<num>end:
>>

not_expr(expr) ::= <<
<expr>
iconst_1
ixor
>>

and_expr(left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
iand
>>

ineg_expr(expr) ::= <<
<expr>
ineg
>>

fneg_expr(expr) ::= <<
<expr>
fneg
>>


// Mapeamento de tipos
array_type(type) ::= "[<type>"
int_type() ::= "I"
float_type() ::= "F"
boolean_type() ::= "Z"
char_type() ::= "C"

// Expressões de valores
boolean_true() ::= "iconst_1"
boolean_false() ::= "iconst_0"
float_expr(value) ::= "ldc <value>"
int_expr(value) ::= "sipush <value>"
char_expr(value) ::= "ldc <value>"

// ==================== TEMPLATE AUXILIAR ====================
empty() ::= <<>>