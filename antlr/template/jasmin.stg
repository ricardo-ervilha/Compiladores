group jasmin;

program(name, funcs) ::= <<
.source <name>
.class public <name>
.super java/lang/Object

    <funcs; separator="\n\n">

    .method public static main([Ljava/lang/String;)V
        .limit stack 1
        invokestatic <name>/main_aux()V
        return
    .end method
>>


// Template para funções
func(return, name, params, decls, stack, stmt) ::= <<
.method static <name>(<params>)<return>
    .limit stack <stack>
    .limit locals <decls>
    <stmt>
.end method
>>

// Template para um bloco: uma sequência de comandos
block(cmds) ::= <<
    <cmds; separator="\n">
>>

empty() ::= <<>>
iprint(expr) ::= <<
getstatic java/lang/System/out Ljava/io/PrintStream;
<expr>
invokevirtual java/io/PrintStream/println(I)V
>>

fprint(expr) ::= <<
getstatic java/lang/System/out Ljava/io/PrintStream;
<expr>
invokevirtual java/io/PrintStream/println(F)V
>>

cprint(expr) ::= <<
getstatic java/lang/System/out Ljava/io/PrintStream;
<expr>
invokevirtual java/io/PrintStream/println(C)V
>>

bprint(expr) ::= <<
getstatic java/lang/System/out Ljava/io/PrintStream;
<expr>
invokevirtual java/io/PrintStream/println(Z)V
>>

ireturn(expr) ::= <<
<expr>
ireturn
>>

freturn(expr) ::= <<
<expr>
freturn
>>

vreturn() ::= <<

return
>>

while(num,expr, stmt) ::= <<
Label<num>:
<expr>
ifeq Label<num>end
<stmt>
goto Label<num>
Label<num>end:
nop
>>

// Template para if-else
if_else(elseNum, endNum, expr, thenBlock, elseBlock) ::= <<
<expr>
ifeq Label<elseNum>
<thenBlock>
    goto Label<endNum>
Label<elseNum>:
<elseBlock>
Label<endNum>:
>>

// ==================== STORE VARIAVEL SIMPES (PILHA --> STORE) ====================

store_int(index, rhs) ::= <<
<rhs>
istore <index>
>>

store_float(index, rhs) ::= <<
<rhs>
fstore <index>
>>

// ==================== LOAD VARIAVEL SIMPES (STORE --> PILHA) ====================
load_int(index) ::= <<
iload <index>
>>

load_float(index) ::= <<
fload <index>
>>

// ==================== STORE ELEMENTO DE ARRAY ====================

astore_int_array(arrayRef, indexExpr, rhs) ::= <<
<arrayRef>
<indexExpr>
<rhs>
iastore
>>

astore_float_array(arrayRef, indexExpr, rhs) ::= <<
<arrayRef>
<indexExpr>
<rhs>
fastore
>>

// ==================== STORE REGISTRO ====================
putfield_int(objRef, fieldName, fieldDescriptor, rhs) ::= <<
<objRef>
<rhs>
putfield <fieldName> <fieldDescriptor>
>>

putfield_float(objRef, fieldName, fieldDescriptor, rhs) ::= <<
<objRef>
<rhs>
putfield <fieldName> <fieldDescriptor>
>>




iarray(num, expr) ::= <<
<expr>
newarray int
astore <num>
>>

call(class, name, type, return, args) ::= <<
<args; separator="\n">
invokestatic <class>/<name>(<type>)<return>
>>

istore(num, expr) ::= <<
<expr>
istore <num>
>>

iastore(num, index, expr) ::= <<
aload <num>
<index>
<expr>
iastore
>>

iaccess(num) ::= "iload <num>"

iaaccess(num, expr) ::= <<
aload <num>
<expr>
iaload
>>

iaload(num) ::= <<
aload <num>
>>


// Operadores Binários e Unários: Aritméticos e Relacionais
imul(left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
imul
>>

idiv(left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
idiv
>>

imod(left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
irem
>>

iadd(left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
iadd
>>

isub(left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
isub
>>

ilt_expr(num, left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
isub
iflt Label<num>
    iconst_0
    goto Label<num>end
Label<num>:
    iconst_1
Label<num>end:
>>

flt_expr(num, left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
fcmpl
iflt Label<num>
    iconst_0
    goto Label<num>end
Label<num>:
    iconst_1
Label<num>end:
>>

iequals_expr(num, left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
isub
ifeq Label<num>
    iconst_0
    goto Label<num>end
Label<num>:
    iconst_1
Label<num>end:
>>

fequals_expr(num, left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
fcmpl
ifeq Label<num>
    iconst_0
    goto Label<num>end
Label<num>:
    iconst_1
Label<num>end:
>>

not_expr(expr) ::= <<
<expr>
iconst_1
ixor
>>

and_expr(left_expr, right_expr) ::= <<
<left_expr>
<right_expr>
iand
>>

ineg_expr(expr) ::= <<
<expr>
ineg
>>

fneg_expr(expr) ::= <<
<expr>
fneg
>>


// Mapeamento de tipos
array_type(type) ::= "[<type>"
int_type() ::= "I"
float_type() ::= "F"
boolean_type() ::= "Z"
char_type() ::= "C"

// Expressões de valores
boolean_true() ::= "iconst_1"
boolean_false() ::= "iconst_0"
float_expr(value) ::= "ldc <value>"
int_expr(value) ::= "sipush <value>"
char_expr(value) ::= "ldc <value>"
