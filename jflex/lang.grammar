%package "parsers";
%import "ast.*";

%class "Lang";

%terminals ID, TYID, INT_NUM, FLOAT_NUM, CHAR_NUM, TRUE, FALSE, NULL, OPEN_PARENTHESES, CLOSE_PARENTHESES, OPEN_BRACKETS, CLOSE_BRACKETS
OPEN_BRACES, CLOSE_BRACES, GREATER, SEMICOLON, DOUBLE_POINTS, DOUBLE_DOUBLE_POINTS, DOT, COLON, EQ, LESS, EQ_EQ, DIFF, PLUS
MINUS, TIMES, DIVIDE, MOD, AND, NOT, NOT_EQUAL, ABSTRACT, DATA, INT, CHAR, BOOL, FLOAT, IF
ELSE, ITERATE, READ, PRINT, RETURN, NEW

%goal Prog;

Prog = stmtList.s               {: return ; :}
    ;

/*Recursão no Prog*/
stmtList = def.s stmtList.l    {: return  :}
    | def.s                   {: return ; :}
    |
    ;

def = data                 {: return ; :}
        | fun              {: return ; :}
    ;

data = ABSTRACT DATA TYID.s OPEN_BRACES func_decl_stmtList.l CLOSE_BRACES         {: return :}
    | DATA TYID.s OPEN_BRACES decl_stmtList.l CLOSE_BRACES                        {: return :}
    ;

/*Recursão na declaração ou função do tipo abstrato*/
func_decl_stmtList = decl func_decl_stmtList                          {: return }
            | func func_decl_stmtList                                 {: return }
            | 
        ;
/*Recursão na declaração de novo tipo de dado*/
decl_stmtList = decl decl_stmtList                              {: return }
            |                                                   {: return }
            ;

/*Declaração de tipo da linguagem*/
decl = ID DOUBLE_DOUBLE_POINTS type SEMICOLON
    ;

/*Declaração de função*/
fun = ID OPEN_PARENTHESES params CLOSE_PARENTHESES return_stmlList cmd
    ;

/*Retorno da função opcional*/
return_stmlList = DOUBLE_POINTS type type_stmtList
        |
    ;

/*Recursão do retorno da função*/
type_stmtList = COLON type type_stmtList
    |
    ;

/*Parte dos parametros que podem existir 1 ou mais e nenhum por ser opcional*/
params = ID DOUBLE_DOUBLE_POINTS type  params_stmtList
    |
    ;

/*Recursão para o caso de vários parâmetros*/
params_stmtList = COLON ID DOUBLE_DOUBLE_POINTS type params_stmtList
    |
    ;

/*Provável vetor*/
type = type OPEN_BRACKETS CLOSE_BRACKETS
    | btype
    ;

/*Nome do tipo*/
btype = INT
    | CHAR
    | BOOL
    | FLOAT
    | TYID
    ;

/*Regra do bloco*/
block = OPEN_BRACKETS cmd_stmtList CLOSE_BRACKETS

/*Recursão de cmd dentro do bloco*/
cmd_stmtList = cmd | cmd_stmtList
    |
    ;

cmd = block
    | IF OPEN_PARENTHESES exp CLOSE_PARENTHESES cmd 
    | IF OPEN_PARENTHESES exp CLOSE_PARENTHESES ELSE cmd
    | ITERATE OPEN_PARENTHESES itcond CLOSE_PARENTHESES cmd
    | READ lvalue SEMICOLON
    | PRINT exp SEMICOLON
    | RETURN exp exp_stmtList SEMICOLON 
    | lvalue EQ exp SEMICOLON
    | ID OPEN_PARENTHESES exps CLOSE_PARENTHESES return_call_function SEMICOLON

/*recursão no retorno dentro do bloco da função*/
exp_stmtList = COLON exp 
    | 
    ;

return_call_function = LESS lvalue lvalue_stmtList GREATER

lvalue_stmtList = COLON lvalue lvalue_stmtList
    |
    ;

itcond = ID DOUBLE_POINTS exp 
    | exp
    ;

exp = exp op exp
    | NOT exp 
    | MINUS exp 
    | lvalue
    | OPEN_PARENTHESES exp CLOSE_PARENTHESES
    | NEW type type_brackets
    | ID OPEN_PARENTHESES exps CLOSE_PARENTHESES OPEN_BRACKETS exp CLOSE_BRACKETS
    | TRUE 
    | FALSE
    | NULL
    | INT
    | FLOAT
    | CHAR

type_brackets = OPEN_BRACKETS exp CLOSE_BRACKETS

op = AND AND 
    | LESS
    | GREATER
    | EQ_EQ
    | DIFF
    | PLUS
    | MINUS
    | TIMES
    | DIVIDE
    | MOD

lvalue = ID 
    | lvalue OPEN_BRACKETS exp CLOSE_BRACKETS
    | lvalue DOT ID

exps = exp exps_stmtList

exps_stmtList = COLON exp exps_stmtList
    |
    ;